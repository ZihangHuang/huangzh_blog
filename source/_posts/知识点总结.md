---
title: 知识点总结
date: 2020-07-26 18:27:51
categories: 前端
tags: 技术
---
常用知识点
<!-- more -->

### 内置类型
六个基本类型（es6新增symbol）和引用类型

### 作用域与闭包

### 原型和继承

```javascript
// 模拟根据原型链查找属性
function  getProp(obj, prop) {
  let proto = obj;
  while(proto && proto[prop] === void 0) {
    proto = proto.__proto__;
  }
  return proto === null ? void 0 : obj[prop];
}

// 模拟new过程
function myNew(constructor, ...args) {
  const obj = {};
  obj.__proto__ = constructor.prototype;
  const ret = constructor.call(obj, ...args);
  return ret instanceof Object ? ret : obj;
}
```

#### es5和es6继承区别：
es5是先创建子类的实例对象，然后通过Parent.call(this)把父类的属性添加进子实例的this。
es6是先创建父类的实例对象this，用super()把该this添加到子类，子类原本是没有this，所以不能在super()前使用this。
es5不能继承原生构造函数的属性，如一个构造函数继承自Array，但也没有length属性。
es6可以继承原生构造函数的属性。

```javascript
function changeObjProperty(o) {
  // o这个形参实际可以写成var o = webSite
  o.siteUrl = "http://www.baidu.com"
  // 指向新的对象了
  o = new Object()
  o.siteUrl = "http://www.google.com"
} 
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
// "http://www.baidu.com"
```

### 浏览器和Node 事件循环的区别

```javascript
function test () {
   console.log('start')
    setTimeout(() => {
        console.log('children2')
        Promise.resolve().then(() => {console.log('children2-1')})
    }, 0)
    setTimeout(() => {
        console.log('children3')
        Promise.resolve().then(() => {console.log('children3-1')})
    }, 0)
    Promise.resolve().then(() => {console.log('children1')})
    console.log('end') 
}

test()

// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)
// start
// end
// children1
// children2
// children3
// children2-1
// children3-1

// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)
// start
// end
// children1
// children2
// children2-1
// children3
// children3-1
```

### createObjectURL
使用window.URL.createObjectURL预览图片，在图片加载成功后需要清除使用的内存window.URL.revokeObjectURL(src);

### 白屏时间和首屏时间
白屏是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。  
首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。  
影响白屏时间的因素：网络，服务端性能，前端页面结构设计。  
影响首屏时间的因素：白屏时间，资源下载执行时间。

简单的计算白屏时间：在`window.onload`里执行`new Date() - performance.timing.navigationStart`，或者获取`performance.now()`

`performance.timing.navigationStart + performance.now()` 约等于 `Date.now()`。

`performance.getEntries()`方法可以查询页面内加载的所有资源的开始时间、耗时等信息，包括css、js、图片、字体文件、异步请求等。

### 关闭页面弹出确认弹窗

```javascript
window.addEventListener('beforeunload', event => {
  // Cancel the event as stated by the standard.
  event.preventDefault();
  // Chrome requires returnValue to be set.
  event.returnValue = '';
});
```




### 兼容性问题

- IE6中，第一个浮动到父元素边上的元素，如果含有该方向的margin值，那么margin会以双倍显示。即：浮动元素的左边距在IE6上为所设定的左边距的两倍。这个问题只会发生在浮动行的第一个浮动元素上。准确的说：应该是每一行的第一个元素都会受此影响。
为了解决该问题，需要给浮动元素添加属性display: inline，即可解决。

- iOS11中position:fixed弹出框中的input光标错位的问题  
在弹框出现的时候给body添加fixed:
```css
body{ position: fixed; width: 100%;}
```
  当弹框消失的时候
```css
$("body").css("position","relative")
```
- IOS设置position:fixed，键盘遮住输入框

```javascript
// 设置一个定时器在输入框获取焦点的时候一直刷新输入框的位置，然后在失去焦点的时候清除
clearInterval(this.resizeInputInterval);
this.resizeInputInterval = setInterval(() => {
  this.input.scrollIntoView(true); // 元素的顶端将和其所在滚动区的可视区域的顶端对齐
}, 100);
```

```javascript
var windheight = $(window).height();  /*未唤起键盘时当前窗口高度*/
$(window).resize(function(){
   var docheight = $(window).height();  /*唤起键盘时当前窗口高度*/        
   if(docheight < windheight){            /*当唤起键盘高度小于未唤起键盘高度时执行*/
      $("input").css("position","static");
   }else{
      $("input").css("position","fixed");
   }           
});
// 或者在输入框聚焦失焦时设置position
```

### 计算机网络

| OSI七层 | TCP/IP4层 | 协议或设备 |
| ------- | --------- | --- |
| 应用层 | 应用层  | HTTP |
| 表示层 | 应用层  |  Telnet |
| 会话层 | 应用层  |  SMTP, DNS |
| 传输层 | 传输层 | TCP, UDP |
| 网络层 | 网络层 | IP,路由器 |
| 数据链路层 | 数据链路层 | 网桥,交换机 |
| 物理层 | 物理层 | 网卡 |


#### 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？

这是由于服务端的LISTEN状态下的SOCKET当收到SYN报文的建立请求后。它能够把ACK和SYN（ACK起应答作用。而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它只表示对方没有数据发送给你了。但服务端可能还需要再发送一些数据给客户端。所以服务端不能立即会关闭SOCKET，先发送ACK客户端，等服务器确认可以关闭了，再发送FIN报文给对方来表示它也能够关闭连接了。服务端这里的ACK报文和FIN报文多数情况下都是分开发送的。

A：B 啊，我不想玩了。
B：哦，你不想玩了啊，我知道了。
B：A 啊，好吧，我也不玩了，拜拜。
A：好的，拜拜。

### IntersectionObserver

```javascript
//监听area出现在屏幕时做一些事件
var io = new IntersectionObserver(function(entries) {
    entries.forEach(item => {
        if(item.intersectionRatio > 0) {
            //Appears on the viewport
        }else {
            //Leave in the viewport
        }
    });
});

io.observe(document.getElementById('area'));
```

### 异步脚本

`<script src="script.js"></script>`

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

`<script async src="script.js"></script>`

有 async，加载和渲染后续文档元素的过程将和 script.js 的加载并行（异步）。是乱序执行，不管你声明的顺序如何，只要它加载完了就会立刻执行，执行还是会堵塞文档解析。

`<script defer src="myscript.js"></script>`

有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。会按照加载顺序执行脚本。

### 文件顺序

`为什么通常推荐将 CSS <link> 放置在 <head></head> 之间，而将 JS <script> 放置在 </body> 之前？你知道有哪些例外吗？`

浏览器从上到下依次解析html文档。将 css 文件放到头部， css 文件可以先加载。
避免先加载 body 内容，导致页面一开始样式错乱，然后闪烁。将 javascript 文件放到底部是因为：
若将 javascript 文件放到 head 里面，就意味着必须等到所有的 javascript 代码都被 下载、解析和执行完成
之后才开始呈现页面内容。这样就会造成呈现页面时出现明显的延迟，窗口一片空白。
为避免这样的问题一般将全部 javascript 文件放到 body 元素中页面内容的后面。
页面加载的问题，先把页面加载出来，然后再去加载效果，提高用户体验度。

CSS下载不会阻塞DOM的解析，但是阻塞页面渲染。
`<script>`与`<link>`同时在头部的话，`<script>`在上可能会更好了。因为js可能需要获取css的内容，如果`<link>`在前面的话，本来不会阻塞DOM的解析，但是js会阻塞，然后js又得等待css下载完，结果造成css和js一起阻塞DOM解析。

浏览器遇到 `<script>`且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。

### 浏览器缓存

Last-Modified->If-Modified-Since

Etag->If-None-Match

### 输入url到页面展示过程

- dns解析
  浏览器缓存->操作系统缓存->本地host文件->路由器缓存->网络提供商缓存->顶级DNS服务器/根DNS服务器
- TCP连接（三次握手）
- 发送HTTP请求
  请求头第一行：`GET /www.baidu.com HTTP/1.1`
- 服务器处理请求
  反向代理服务器->应用服务器
- 服务器响应请求
  响应头第一行：`HTTP/1.1 200 OK`
- 浏览器解析HTML生成DOM，解析CSS生成CSSOM，执行JavaScript，样式计算，构造布局树，准备绘制列表，光栅化，合成，显示。
  （构建dom树->构建render树->布局render树->绘制render树）

  整个页面解析过程 大致是这样：
  HTMLparser  解析dom  -> Recalculate style 解析css stylesheets -> 构建布局树 -> 布局计算 -> 创建分层树 , 创建图层-> 图层绘制成一个绘制列表 （浏览器主进程）-> （合成线程）光栅化，根据视口将图层切分成图块，最后交给GPU进程合成位图，存放在GPU内存中
  - 连接结束（四次挥手）

### 常用性能优化

- 减少HTTP请求
- 使用服务器端渲染
- 静态资源使用cdn
- css放头部，js放尾部
- 使用字体图标，小的图片使用base64直接写在css
- 缓存
- 压缩文件
- 懒加载
- 按需加载
- 减少重排回流
- 使用requestAninationFrame代替定时器来实现动画

### webpack性能优化

- 使用DllPlugin动态链接库插件减少基础模块编译次数，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。
- 使用HappyPack开启多进程Loader转换。在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能。
- 压缩代码-JS、ES、CSS
- 分割代码以按需加载

### 箭头函数与普通函数区别

- 箭头函数是匿名函数，不能作为构造函数，不能使用new
- 箭头函数没有prototype
- 普通函数的this非严格模式下指向window，严格模式指向undefined。箭头函数两种模式下都继承自上一层作用域的this。所以对象的方法不宜使用箭头函数，它的this是指向外层函数的，如果没有外层函数则指向全局对象。call()、apply()、bind()也不能改变箭头函数的this。
- 箭头函数不能使用new.target和arguments，如果是套在普通函数内，则这两个都指向普通函数。
- 对象的方法不宜使用箭头函数，它的是指向外层函数的，如果没有外层函数则指向全局对象。

### encodeURI和encodeURIComponent
encodeURI方法不会对下列字符编码  ASCII字母  数字  ~!@#$&*()=:/,;?+'
encodeURIComponent方法不会对下列字符编码 ASCII字母  数字  ~!*()'
所以encodeURIComponent比encodeURI编码的范围更大。实际例子来说，encodeURIComponent会把`http://`编码成`http%3A%2F%2F`而encodeURI却不会。

如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。
当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。

### react生命周期函数

- 初始化创建组件阶段：
父组件：constructor -> componentWillMount -> render ->
子组件：constructor -> componentWillMount -> render -> componentDidMount ->
父组件：componentDidMount
- 更新阶段：
父组件：componentWillUpdate -> render ->
子组件：componentWillReceiveProps -> componentWillUpdate -> render -> componentDidUpdate ->
父组件：componentDidUpdate
- 卸载阶段：
父组件：componentWillUnmount
子组件：componentWillUnmount

### 判断数据类型

```javascript
// 使用typeof
console.log(typeof bool); //boolean
console.log(typeof num);//number
console.log(typeof str);//string
console.log(typeof und);//undefined
console.log(typeof nul);//object
console.log(typeof arr);//object
console.log(typeof obj);//object
console.log(typeof fun);//function

// 使用instanceof ，即使是Boolean，Number,String数据类型也要用new，除了null和undefined

// Object.prototype.toString.call,不能检测非原生构造函数的构造函数名。
console.log(Object.prototype.toString.call(bool));//[object Boolean]
console.log(Object.prototype.toString.call(num));//[object Number]
console.log(Object.prototype.toString.call(str));//[object String]
console.log(Object.prototype.toString.call(und));//[object Undefined]
console.log(Object.prototype.toString.call(nul));//[object Null]
console.log(Object.prototype.toString.call(arr));//[object Array]
console.log(Object.prototype.toString.call(obj));//[object Object]
console.log(Object.prototype.toString.call(fun));//[object Function]
```

### HTTP2

- 二进制传输。  
http1.x是文本传输。为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。
- 多路复用。  
所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。
- Header压缩
- 服务器推送
- 更安全。  
HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。

### webpack原理

1. 先解析webpack配置参数,合并shell中的输入和配置文件如webpack.config.js中的参数,最后生成配置结果;

2. 注册所有配置的插件,好让插件监听webpack构建生命周期的事件节点,并作出响应;

3. 从配置文件中的入口文件entry开始解析文件,构建AST,找出每个文件依赖的文件,递归下去;

4. 在解析文件递归过程中根据文件类型和对应的loader配置找出合适的插件进行解析;

5. 递归结束后得到每个文件的最终结果,根据entry配置生成代码块chunk;

6. 输出所有chunk到文件系统