---
title: 函数绑定和函数柯里化
date: 2018-06-30 18:45:19
categories: 技术
tags: [前端]
---

最近比较闲，看了会书，打打基础。下面记录一下看过的一些内容。

### 函数绑定

函数绑定要创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。常常和回调函数与实践处理程序一起使用，以便将函数作为变量传递的同时保留代码执行环境。

<!--more-->

例如：

```javascript
var handler = {
	message: 'Event handled',
	handleClick: function(event){
		alert(this.message)
	}
}

var btn = document.getElementById('my-btn')
EventUtil.addHandler(btn, 'click', handler.handleClick)
```

我们在一个按钮注册了点击事件，希望点击它会弹出 Event handled，然而实际上显示的是 undefined。原因是没有保存 handle.handleClick()的环境，所以 this 对象最后指向的是按钮而不是 handler（在 ie8 中，this 指向 window）。
可以使用一个闭包来修正这个问题：

```javascript
var handler = {
	message: 'Event handled',
	handleClick: function(event){
		alert(this.message)
	}
}

var btn = document.getElementById('my-btn')
EventUtil.addHandler(btn, 'click', function(event){
	handler.handleClick(event)
})
```

但是闭包使用过多会难以理解和调试，因此可以使用一个将函数绑定到指定环境的函数，这个函数一般叫 bind()。
实现一个简单的 bind()函数：

```javascript
function bind(fn, context){
	return function(){
		return fn.apply(context, arguments)
	}
}
```

这个函数似乎简单，但功能强大。在 bind()中创建一个闭包，使用 apply()调用传入的函数，并给 apply()传递 context 对象和参数。注意这里的 arguments 是内部函数的，而非 bind()。当调用返回函数时，它会在给定环境执行被传入的函数并给出所有参数。
使用如下：

```javascript
var handler = {
	message: 'Event handled',
	handleClick: function(event){
		alert(this.message)
	}
}

var btn = document.getElementById('my-btn')
EventUtil.addHandler(btn, 'click', bind(handler.handleClick, handler))
```

event 对象也会传给函数，因为所有的参数都通过被绑定的函数直接传给它。
ECMAScript5 原生定义了一个 bind()方法，操作更简单：

```javascript
var handler = {
	message: 'Event handled',
	handleClick: function(event){
		alert(this.message)
	}
}

var btn = document.getElementById('my-btn')
EventUtil.addHandler(btn, 'click', handler.handleClick.bind(handler))
```

### 函数柯里化

函数柯里化是用于创建已经设置好了一个或者多个参数的函数。基本方法和函数绑定是一样的：使用一个闭包返回函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。请看一下例子：

```javascript
function add(num1, num2){
	return num1 + num2;
}
function curriedAdd(num2){
	return add(5, num2)
}

alert(add(2,3))		//5
alert(curriedAdd(3)) 	//8
```

这里定义了两个函数，后者本质上是在任何情况下第一个参数为 5 的 add()版本。尽管从技术上来说 curriedAdd()并非柯里化的函数，但它很好地展示了概念。
下面是创建柯里化函数的通用方法：

```javascript
function curry(fn){
	//获取传入的参数，第一个参数为进行柯里化的函数，因此要排除
	var args = Array.prototype.slice.call(arguments,1)
	return function(){
		//获取返回的函数的参数
		var innerArgs = Array.prototype.slice.call(arguments)
		//把两个函数的参数合并起来
		var finalArgs = args.concat(innerArgs)
		return fn.apply(null, finalArgs)
    }
}
```

curry()的第一个函数是要进行柯里化的函数，其他值是要传入的值。finalArgs 是合并完的参数，使用 apply()将结果传递给 fn。

使用如下：

```javascript
function add(num1, num2){
	return num1 + num2;
}
var curriedAdd = curry(add, 5)
alert(curriedAdd(3)) 		//8
```

在这个例子中，创建了第一个参数为 5 的 add()的柯里化版本。当调用 curriedAdd()并传入 3 时，3 会成为 add()的第二个参数，结果便是 8。

函数柯里化和函数绑定结合在一起，则为：

```javascript
function bind(fn, context){
	//获取传入的参数，第一个参数为进行柯里化的函数，第二个参数为传入的上下文，因此要排除
	var args = Array.prototype.slice.call(arguments,2)
	return function(){
		//获取返回的函数的参数
		var innerArgs = Array.prototype.slice.call(arguments)
		//把两个函数的参数合并起来
		var finalArgs = args.concat(innerArgs)
		return fn.apply(context, finalArgs)
    }
}
```

当你想除了 event 对象再额外给上面的事件处理程序传递参数时，可以直接再传入一个参数。

```javascript
var handler = {
	message: 'Event handled',
	handleClick: function(name, event){
		alert(this.message + ':' + 'name' + ':' + event.type)
	}
}

var btn = document.getElementById('my-btn')
EventUtil.addHandler(btn, 'click', bind(handler.handleClick, handler, 'mybtn'))
```

在这个更新过的例子中，作为第三个参数传递给 bind()的名字，被传递给了 handler.handleClick()。而 handler.handleClick()页同时接收到 event 对象。

ECMAScript5 的 bind()方法也实现了函数柯里化，只要在 this 的值之后再传入另一个参数即可。

```javascript
var handler = {
	message: 'Event handled',
	handleClick: function(name, event){
		alert(this.message + ':' + 'name' + ':' + event.type)
	}
}

var btn = document.getElementById('my-btn')
EventUtil.addHandler(btn, 'click', handler.handleClick.bind(handler, 'mybtn'))
```
